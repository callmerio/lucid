# Lucid æµè§ˆå™¨æ‰©å±• - ç¤ºä¾‹å’Œæ•™ç¨‹é›†åˆ

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¶é—´**: 2025-06-24 21:11:39  
**é€‚ç”¨ç‰ˆæœ¬**: æ–°æ¶æ„ v1.0+

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› Lucid æµè§ˆå™¨æ‰©å±•æ–°æ¶æ„çš„å®Œæ•´ç¤ºä¾‹å’Œæ•™ç¨‹ï¼ŒåŒ…æ‹¬å¸¸ç”¨åœºæ™¯ã€æ‰©å±•å¼€å‘æŒ‡å—å’Œæ•…éšœæ’æŸ¥æ–¹æ³•ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹ç¤ºä¾‹

### 1. åŸºç¡€ Tooltip æ˜¾ç¤º

æœ€ç®€å•çš„ Tooltip ä½¿ç”¨ç¤ºä¾‹ï¼š

```typescript
import { TooltipManager } from '@utils/dom/managers/TooltipManager';

// è·å–ç®¡ç†å™¨å®ä¾‹
const tooltipManager = TooltipManager.getInstance();

// åŸºç¡€ä½¿ç”¨
async function showBasicTooltip() {
  const targetElement = document.getElementById('word-span');
  
  await tooltipManager.showTooltip({
    word: 'hello',
    translation: 'ä½ å¥½',
    targetElement: targetElement
  });
}

// ç»‘å®šé¼ æ ‡äº‹ä»¶
document.querySelectorAll('.word').forEach(element => {
  element.addEventListener('mouseenter', async () => {
    const word = element.textContent;
    const translation = await getTranslation(word); // å‡è®¾çš„ç¿»è¯‘å‡½æ•°
    
    await tooltipManager.showTooltip({
      word,
      translation,
      targetElement: element as HTMLElement
    });
  });
  
  element.addEventListener('mouseleave', () => {
    tooltipManager.hideTooltip();
  });
});
```

### 2. å®Œæ•´åŠŸèƒ½ Tooltip

åŒ…å«éŸ³æ ‡ã€è¯æ€§å’Œä¾‹å¥çš„å®Œæ•´ç¤ºä¾‹ï¼š

```typescript
async function showFullTooltip() {
  const element = document.getElementById('target-word');
  
  await tooltipManager.showTooltip({
    word: 'beautiful',
    translation: 'ç¾ä¸½çš„ï¼Œæ¼‚äº®çš„',
    phonetic: '/ËˆbjuËtÉªfl/',
    partOfSpeech: 'adjective',
    targetElement: element,
    preferredPosition: 'top'
  });
}
```

## ğŸ¯ å¸¸ç”¨åœºæ™¯ç¤ºä¾‹

### åœºæ™¯1: ç½‘é¡µæ–‡ç« é˜…è¯»åŠ©æ‰‹

ä¸ºç½‘é¡µæ–‡ç« æ·»åŠ å•è¯æŸ¥è¯¢åŠŸèƒ½ï¼š

```typescript
class ArticleReadingAssistant {
  private tooltipManager: TooltipManager;
  
  constructor() {
    this.tooltipManager = TooltipManager.getInstance();
    this.initializeReadingMode();
  }
  
  private initializeReadingMode(): void {
    this.enableWordSelection();
    this.setupKeyboardShortcuts();
    this.setupStateListeners();
  }
  
  private enableWordSelection(): void {
    document.addEventListener('mouseup', async (event) => {
      const selection = window.getSelection();
      const selectedText = selection?.toString().trim();
      
      if (!selectedText || selectedText.length > 50) {
        return;
      }
      
      if (this.isSingleWord(selectedText)) {
        await this.showWordTooltip(selectedText, event.target as HTMLElement);
      }
    });
  }
  
  private async showWordTooltip(word: string, element: HTMLElement): Promise<void> {
    try {
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      await this.tooltipManager.showTooltip({
        word,
        translation: 'æŸ¥è¯¢ä¸­...',
        targetElement: element
      });
      
      // æŸ¥è¯¢ç¿»è¯‘ï¼ˆæ¨¡æ‹ŸAPIè°ƒç”¨ï¼‰
      const definition = await this.getTranslation(word);
      
      // æ›´æ–°å†…å®¹
      await this.tooltipManager.showTooltip({
        word,
        translation: definition.translation,
        phonetic: definition.phonetic,
        partOfSpeech: definition.partOfSpeech,
        targetElement: element
      });
      
    } catch (error) {
      console.error('æŸ¥è¯¢å•è¯å¤±è´¥:', error);
      await this.tooltipManager.showTooltip({
        word,
        translation: 'æŸ¥è¯¢å¤±è´¥ï¼Œè¯·é‡è¯•',
        targetElement: element
      });
    }
  }
  
  private setupKeyboardShortcuts(): void {
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        this.tooltipManager.hideTooltip(true);
      }
      if (event.key === 'Enter' && this.tooltipManager.isVisible()) {
        this.tooltipManager.toggleExpanded();
      }
    });
  }
  
  private setupStateListeners(): void {
    this.tooltipManager.addStateChangeListener((event) => {
      switch (event.type) {
        case 'show':
          this.recordLookup(event.state.word);
          break;
        case 'hide':
          document.body.classList.remove('tooltip-active');
          break;
      }
    });
  }
  
  private isSingleWord(text: string): boolean {
    return /^[a-zA-Z-']+$/.test(text) && !text.includes(' ');
  }
  
  private async getTranslation(word: string): Promise<any> {
    // æ¨¡æ‹Ÿç¿»è¯‘API
    return {
      translation: 'ç¤ºä¾‹ç¿»è¯‘',
      phonetic: '/ËˆeksÉ™mpl/',
      partOfSpeech: 'noun'
    };
  }
  
  private recordLookup(word: string): void {
    const history = JSON.parse(localStorage.getItem('word-history') || '[]');
    history.push({ word, timestamp: Date.now() });
    localStorage.setItem('word-history', JSON.stringify(history.slice(-100)));
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const assistant = new ArticleReadingAssistant();
```

### åœºæ™¯2: å­¦ä¹ æ¨¡å¼å¢å¼º

ä¸ºåœ¨çº¿å­¦ä¹ å¹³å°æ·»åŠ æ™ºèƒ½å­¦ä¹ åŠ©æ‰‹ï¼š

```typescript
class LearningModeEnhancer {
  private tooltipManager: TooltipManager;
  private learningStats = {
    wordsLearned: 0,
    correctAnswers: 0,
    totalAttempts: 0
  };
  
  constructor() {
    this.tooltipManager = TooltipManager.getInstance();
    this.setupLearningMode();
  }
  
  private setupLearningMode(): void {
    this.addQuizMode();
    this.addProgressTracking();
  }
  
  private addQuizMode(): void {
    // åŒå‡»å•è¯è¿›å…¥æµ‹è¯•æ¨¡å¼
    document.addEventListener('dblclick', async (event) => {
      const target = event.target as HTMLElement;
      const word = this.extractWord(target);
      
      if (word) {
        await this.startWordQuiz(word, target);
      }
    });
  }
  
  private async startWordQuiz(word: string, element: HTMLElement): Promise<void> {
    const definition = await this.getWordDefinition(word);
    
    await this.tooltipManager.showTooltip({
      word,
      translation: this.createQuizInterface(definition),
      targetElement: element,
      preferredPosition: 'bottom'
    });
    
    this.setupQuizInteraction(word, definition);
  }
  
  private createQuizInterface(definition: any): string {
    return `
      <div class="quiz-interface">
        <div class="quiz-question">è¿™ä¸ªå•è¯çš„æ„æ€æ˜¯ï¼Ÿ</div>
        <div class="quiz-options">
          <button class="quiz-option" data-answer="correct">${definition.translation}</button>
          <button class="quiz-option" data-answer="wrong">${this.getRandomTranslation()}</button>
          <button class="quiz-option" data-answer="wrong">${this.getRandomTranslation()}</button>
        </div>
        <div class="quiz-stats">å­¦ä¹ è¿›åº¦: ${this.learningStats.wordsLearned} ä¸ªå•è¯</div>
      </div>
    `;
  }
  
  private setupQuizInteraction(word: string, definition: any): void {
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      if (target.classList.contains('quiz-option')) {
        this.handleQuizAnswer(target, word, definition);
      }
    });
  }
  
  private async handleQuizAnswer(button: HTMLElement, word: string, definition: any): Promise<void> {
    const isCorrect = button.dataset.answer === 'correct';
    
    this.learningStats.totalAttempts++;
    if (isCorrect) {
      this.learningStats.correctAnswers++;
      this.learningStats.wordsLearned++;
    }
    
    const resultMessage = isCorrect ? 'âœ… æ­£ç¡®ï¼' : 'âŒ é”™è¯¯ï¼Œæ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š' + definition.translation;
    
    await this.tooltipManager.showTooltip({
      word,
      translation: `
        <div class="quiz-result ${isCorrect ? 'correct' : 'incorrect'}">
          ${resultMessage}
          <div class="learning-progress">
            æ­£ç¡®ç‡: ${Math.round(this.learningStats.correctAnswers / this.learningStats.totalAttempts * 100)}%
          </div>
        </div>
      `,
      targetElement: button.closest('[data-lucid-tooltip]') as HTMLElement
    });
    
    setTimeout(() => this.tooltipManager.hideTooltip(true), 2000);
  }
  
  private addProgressTracking(): void {
    this.tooltipManager.addStateChangeListener((event) => {
      if (event.type === 'show') {
        this.trackLearningActivity(event.state.word);
      }
    });
  }
  
  private extractWord(element: HTMLElement): string | null {
    const selection = window.getSelection();
    const selectedText = selection?.toString().trim();
    
    if (selectedText && /^[a-zA-Z-']+$/.test(selectedText)) {
      return selectedText;
    }
    
    return element.textContent?.match(/\b[a-zA-Z-']+\b/)?.[0] || null;
  }
  
  private async getWordDefinition(word: string): Promise<any> {
    return {
      translation: 'ç¤ºä¾‹ç¿»è¯‘',
      phonetic: '/ËˆeksÉ™mpl/',
      partOfSpeech: 'noun'
    };
  }
  
  private getRandomTranslation(): string {
    const randomTranslations = ['é”™è¯¯é€‰é¡¹1', 'é”™è¯¯é€‰é¡¹2', 'é”™è¯¯é€‰é¡¹3'];
    return randomTranslations[Math.floor(Math.random() * randomTranslations.length)];
  }
  
  private trackLearningActivity(word: string): void {
    const activity = { word, timestamp: Date.now() };
    const activities = JSON.parse(localStorage.getItem('learning-activities') || '[]');
    activities.push(activity);
    localStorage.setItem('learning-activities', JSON.stringify(activities.slice(-1000)));
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const learningEnhancer = new LearningModeEnhancer();
```

## ğŸ”§ æ‰©å±•å¼€å‘æ•™ç¨‹

### æ•™ç¨‹1: åˆ›å»ºè‡ªå®šä¹‰ä½ç½®ç­–ç•¥

```typescript
// ç»§æ‰¿åŸºç¡€ä½ç½®è®¡ç®—å™¨
class CustomPositioner extends TooltipPositioner {
  /**
   * è‡ªå®šä¹‰ä½ç½®è®¡ç®—ï¼šå§‹ç»ˆæ˜¾ç¤ºåœ¨å±å¹•ä¸­å¤®
   */
  calculateCenterPosition(options: PositionOptions): Position {
    const viewport = this.getViewportSize();
    
    return {
      x: viewport.width / 2 - 150,
      y: viewport.height / 2 - 100
    };
  }
  
  calculatePosition(options: PositionOptions): Position {
    if (options.preferredPosition === 'center') {
      return this.calculateCenterPosition(options);
    }
    return super.calculatePosition(options);
  }
  
  private getViewportSize(): { width: number; height: number } {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
}

// ä½¿ç”¨è‡ªå®šä¹‰ä½ç½®ç­–ç•¥
class CustomTooltipManager extends TooltipManager {
  constructor() {
    super();
    this.positioner = new CustomPositioner();
  }
}

const customManager = new CustomTooltipManager();
await customManager.showTooltip({
  word: 'center',
  translation: 'ä¸­å¤®æ˜¾ç¤º',
  targetElement: element,
  preferredPosition: 'center'
});
```

### æ•™ç¨‹2: åˆ›å»ºè‡ªå®šä¹‰æ¸²æŸ“å™¨

```typescript
// åˆ›å»ºæš—è‰²ä¸»é¢˜æ¸²æŸ“å™¨
class DarkThemeRenderer extends TooltipRenderer {
  render(options: TooltipRenderOptions): HTMLElement {
    const element = super.render(options);
    
    element.classList.add('dark-theme');
    this.applyDarkTheme(element);
    
    return element;
  }
  
  private applyDarkTheme(element: HTMLElement): void {
    const style = element.style;
    style.backgroundColor = '#2d3748';
    style.color = '#f7fafc';
    style.border = '1px solid #4a5568';
    style.boxShadow = '0 10px 25px rgba(0, 0, 0, 0.5)';
  }
}

// åˆ›å»ºåŠ¨ç”»æ¸²æŸ“å™¨
class AnimatedRenderer extends TooltipRenderer {
  render(options: TooltipRenderOptions): HTMLElement {
    const element = super.render(options);
    this.addEntranceAnimation(element);
    return element;
  }
  
  private addEntranceAnimation(element: HTMLElement): void {
    element.style.opacity = '0';
    element.style.transform = 'scale(0.8) translateY(-10px)';
    element.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    requestAnimationFrame(() => {
      element.style.opacity = '1';
      element.style.transform = 'scale(1) translateY(0)';
    });
  }
  
  cleanup(): void {
    const element = this.getCurrentTooltip();
    if (element) {
      element.style.opacity = '0';
      element.style.transform = 'scale(0.8) translateY(-10px)';
      setTimeout(() => super.cleanup(), 300);
    } else {
      super.cleanup();
    }
  }
}

// ä½¿ç”¨è‡ªå®šä¹‰æ¸²æŸ“å™¨
const darkManager = new TooltipManager();
darkManager.setRenderer(new DarkThemeRenderer());

const animatedManager = new TooltipManager();
animatedManager.setRenderer(new AnimatedRenderer());
```

### æ•™ç¨‹3: åˆ›å»ºè‡ªå®šä¹‰äº‹ä»¶å¤„ç†å™¨

```typescript
// æ‰‹åŠ¿äº‹ä»¶å¤„ç†å™¨
class GestureEventHandler extends TooltipEventHandler {
  private touchStartTime = 0;
  private touchStartPosition = { x: 0, y: 0 };
  
  constructor(options: EventHandlerOptions) {
    super(options);
    this.setupTouchEvents();
  }
  
  private setupTouchEvents(): void {
    document.addEventListener('touchstart', (event) => this.handleTouchStart(event));
    document.addEventListener('touchend', (event) => this.handleTouchEnd(event));
  }
  
  private handleTouchStart(event: TouchEvent): void {
    const touch = event.touches[0];
    this.touchStartTime = Date.now();
    this.touchStartPosition = { x: touch.clientX, y: touch.clientY };
  }
  
  private handleTouchEnd(event: TouchEvent): void {
    const touchDuration = Date.now() - this.touchStartTime;
    const touch = event.changedTouches[0];
    const distance = this.calculateDistance(
      this.touchStartPosition,
      { x: touch.clientX, y: touch.clientY }
    );
    
    // é•¿æŒ‰æ‰‹åŠ¿
    if (touchDuration > 500 && distance < 10) {
      this.handleLongPress(event);
    }
    
    // æ»‘åŠ¨æ‰‹åŠ¿
    if (distance > 50) {
      this.handleSwipe(event);
    }
  }
  
  private handleLongPress(event: TouchEvent): void {
    const target = event.target as HTMLElement;
    const word = this.extractWordFromElement(target);
    
    if (word) {
      this.showTooltipForWord(word, target);
    }
  }
  
  private handleSwipe(event: TouchEvent): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.hide(true);
    }
  }
  
  private calculateDistance(point1: {x: number, y: number}, point2: {x: number, y: number}): number {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
  }
}

// é”®ç›˜å¿«æ·é”®å¤„ç†å™¨
class KeyboardShortcutHandler extends TooltipEventHandler {
  private shortcuts = new Map<string, () => void>();
  
  constructor(options: EventHandlerOptions) {
    super(options);
    this.setupShortcuts();
  }
  
  private setupShortcuts(): void {
    this.registerShortcut('Ctrl+T', () => this.toggleTooltip());
    this.registerShortcut('Ctrl+E', () => this.expandTooltip());
    this.registerShortcut('Ctrl+H', () => this.hideTooltip());
    
    document.addEventListener('keydown', (event) => {
      this.handleKeyboardShortcut(event);
    });
  }
  
  private registerShortcut(shortcut: string, handler: () => void): void {
    this.shortcuts.set(shortcut, handler);
  }
  
  private handleKeyboardShortcut(event: KeyboardEvent): void {
    const shortcut = this.buildShortcutString(event);
    const handler = this.shortcuts.get(shortcut);
    
    if (handler) {
      event.preventDefault();
      handler();
    }
  }
  
  private buildShortcutString(event: KeyboardEvent): string {
    const parts = [];
    if (event.ctrlKey) parts.push('Ctrl');
    if (event.altKey) parts.push('Alt');
    if (event.shiftKey) parts.push('Shift');
    parts.push(event.key);
    return parts.join('+');
  }
  
  private toggleTooltip(): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.hide();
    } else {
      this.showLastTooltip();
    }
  }
  
  private expandTooltip(): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.expand();
    }
  }
  
  private hideTooltip(): void {
    this.stateManager.hide(true);
  }
}
```

## ğŸš¨ æ•…éšœæ’æŸ¥æŒ‡å—

### å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

#### 1. Tooltip ä¸æ˜¾ç¤º

**æ£€æŸ¥ç›®æ ‡å…ƒç´ **:
```typescript
const targetElement = document.getElementById('target');
if (!targetElement) {
  console.error('ç›®æ ‡å…ƒç´ ä¸å­˜åœ¨');
}

if (!document.contains(targetElement)) {
  console.error('ç›®æ ‡å…ƒç´ ä¸åœ¨ DOM ä¸­');
}

const rect = targetElement.getBoundingClientRect();
if (rect.width === 0 || rect.height === 0) {
  console.error('ç›®æ ‡å…ƒç´ ä¸å¯è§');
}
```

**è°ƒè¯•ä»£ç **:
```typescript
async function debugTooltipDisplay() {
  const manager = TooltipManager.getInstance();
  
  try {
    console.log('ç®¡ç†å™¨ç»Ÿè®¡:', manager.getStats());
    
    await manager.showTooltip({
      word: 'debug',
      translation: 'è°ƒè¯•',
      targetElement: document.body
    });
    
    console.log('æ˜¯å¦å¯è§:', manager.isVisible());
    console.log('å½“å‰å•è¯:', manager.getCurrentWord());
    
  } catch (error) {
    console.error('æ˜¾ç¤ºå¤±è´¥:', error);
    if (error instanceof TooltipError) {
      console.error('é”™è¯¯ä»£ç :', error.code);
    }
  }
}
```

#### 2. ä½ç½®è®¡ç®—é”™è¯¯

**è°ƒè¯•ä½ç½®è®¡ç®—**:
```typescript
function debugPositionCalculation() {
  const manager = TooltipManager.getInstance();
  const targetElement = document.getElementById('target');
  const targetRect = targetElement.getBoundingClientRect();
  
  console.log('ç›®æ ‡å…ƒç´ ä½ç½®:', {
    x: targetRect.left,
    y: targetRect.top,
    width: targetRect.width,
    height: targetRect.height
  });
  
  const viewport = {
    width: window.innerWidth,
    height: window.innerHeight,
    scrollX: window.scrollX,
    scrollY: window.scrollY
  };
  
  console.log('è§†å£ä¿¡æ¯:', viewport);
}
```

**ä¿®å¤ä½ç½®é—®é¢˜**:
```typescript
class FixedPositioner extends TooltipPositioner {
  calculatePosition(options: PositionOptions): Position {
    const basePosition = super.calculatePosition(options);
    const viewport = this.getViewport();
    const tooltipRect = this.getTooltipRect(options.tooltipElement);
    
    // è¾¹ç•Œæ£€æŸ¥å’Œä¿®æ­£
    if (basePosition.x < 0) basePosition.x = 10;
    if (basePosition.x + tooltipRect.width > viewport.width) {
      basePosition.x = viewport.width - tooltipRect.width - 10;
    }
    if (basePosition.y < 0) basePosition.y = 10;
    if (basePosition.y + tooltipRect.height > viewport.height) {
      basePosition.y = viewport.height - tooltipRect.height - 10;
    }
    
    return basePosition;
  }
}
```

#### 3. å†…å­˜æ³„æ¼æ£€æµ‹

```typescript
function detectMemoryLeaks() {
  const initialMemory = (performance as any).memory?.usedJSHeapSize;
  let tooltipCount = 0;
  
  const interval = setInterval(() => {
    tooltipCount++;
    
    const manager = TooltipManager.getInstance();
    manager.showTooltip({
      word: `test-${tooltipCount}`,
      translation: 'æµ‹è¯•',
      targetElement: document.body
    }).then(() => {
      setTimeout(() => manager.hideTooltip(true), 100);
    });
    
    if (tooltipCount % 100 === 0) {
      const currentMemory = (performance as any).memory?.usedJSHeapSize;
      const memoryIncrease = currentMemory - initialMemory;
      
      console.log(`åˆ›å»ºäº† ${tooltipCount} ä¸ª tooltip`);
      console.log(`å†…å­˜å¢é•¿: ${(memoryIncrease / 1024 / 1024).toFixed(2)} MB`);
      
      if (memoryIncrease > 50 * 1024 * 1024) {
        console.warn('æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼');
        clearInterval(interval);
      }
    }
    
    if (tooltipCount >= 1000) {
      clearInterval(interval);
    }
  }, 50);
}
```

#### 4. æ€§èƒ½ä¼˜åŒ–

**æ€§èƒ½åˆ†æ**:
```typescript
class PerformanceAnalyzer {
  private measurements = new Map<string, number[]>();
  
  async measureTooltipPerformance() {
    const manager = TooltipManager.getInstance();
    const testElement = document.createElement('div');
    document.body.appendChild(testElement);
    
    for (let i = 0; i < 50; i++) {
      const startTime = performance.now();
      
      await manager.showTooltip({
        word: `test-${i}`,
        translation: `æµ‹è¯•-${i}`,
        targetElement: testElement
      });
      
      const showTime = performance.now() - startTime;
      this.recordMeasurement('show', showTime);
      
      manager.hideTooltip(true);
      await this.waitForFrame();
    }
    
    document.body.removeChild(testElement);
    this.printResults();
  }
  
  private recordMeasurement(operation: string, time: number): void {
    if (!this.measurements.has(operation)) {
      this.measurements.set(operation, []);
    }
    this.measurements.get(operation)!.push(time);
  }
  
  private printResults(): void {
    for (const [operation, times] of this.measurements) {
      const avg = times.reduce((a, b) => a + b) / times.length;
      const max = Math.max(...times);
      const min = Math.min(...times);
      
      console.log(`${operation}æ“ä½œ:`);
      console.log(`  å¹³å‡: ${avg.toFixed(2)}ms`);
      console.log(`  æœ€å¤§: ${max.toFixed(2)}ms`);
      console.log(`  æœ€å°: ${min.toFixed(2)}ms`);
      
      if (avg > 16) {
        console.warn(`  âš ï¸  ${operation}æ“ä½œå¯èƒ½å½±å“æ€§èƒ½`);
      }
    }
  }
  
  private waitForFrame(): Promise<void> {
    return new Promise(resolve => requestAnimationFrame(() => resolve()));
  }
}
```

**é˜²æŠ–ä¼˜åŒ–**:
```typescript
class OptimizedTooltipManager extends TooltipManager {
  private showDebounce = this.debounce(super.showTooltip.bind(this), 200);
  private hideDebounce = this.debounce(super.hideTooltip.bind(this), 100);
  
  async showTooltip(options: ShowTooltipOptions): Promise<void> {
    return this.showDebounce(options);
  }
  
  hideTooltip(immediate?: boolean): void {
    if (immediate) {
      super.hideTooltip(true);
    } else {
      this.hideDebounce();
    }
  }
  
  private debounce<T extends (...args: any[]) => any>(
    func: T, 
    wait: number
  ): (...args: Parameters<T>) => Promise<ReturnType<T>> {
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>): Promise<ReturnType<T>> => {
      return new Promise((resolve) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          resolve(func(...args));
        }, wait);
      });
    };
  }
}
```

### è°ƒè¯•å·¥å…·

#### å¼€å‘è€…è°ƒè¯•é¢æ¿

```typescript
class TooltipDebugPanel {
  private panel: HTMLElement;
  private manager: TooltipManager;
  
  constructor(manager: TooltipManager) {
    this.manager = manager;
    this.createPanel();
    this.setupRealTimeUpdates();
  }
  
  private createPanel(): void {
    this.panel = document.createElement('div');
    this.panel.innerHTML = `
      <div style="
        position: fixed;
        top: 10px;
        right: 10px;
        width: 300px;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        z-index: 999999;
        font-family: monospace;
        font-size: 12px;
      ">
        <h3>Tooltip è°ƒè¯•é¢æ¿</h3>
        <div id="debug-stats"></div>
        <div>
          <button onclick="this.clearStats()">æ¸…é™¤ç»Ÿè®¡</button>
          <button onclick="this.exportLogs()">å¯¼å‡ºæ—¥å¿—</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(this.panel);
  }
  
  private setupRealTimeUpdates(): void {
    setInterval(() => this.updateStats(), 1000);
  }
  
  private updateStats(): void {
    const stats = this.manager.getStats();
    const statsElement = this.panel.querySelector('#debug-stats');
    
    if (statsElement) {
      statsElement.innerHTML = `
        <div>çŠ¶æ€: ${stats.state.visible ? 'æ˜¾ç¤º' : 'éšè—'}</div>
        <div>å½“å‰å•è¯: ${stats.state.word || 'æ— '}</div>
        <div>æ˜¾ç¤ºæ¬¡æ•°: ${stats.events.totalShows}</div>
        <div>éšè—æ¬¡æ•°: ${stats.events.totalHides}</div>
        <div>å†…å­˜ä½¿ç”¨: ${this.getMemoryUsage()}</div>
      `;
    }
  }
  
  private getMemoryUsage(): string {
    const memory = (performance as any).memory;
    return memory ? `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB` : 'ä¸å¯ç”¨';
  }
}

// ä½¿ç”¨è°ƒè¯•é¢æ¿
const manager = TooltipManager.getInstance();
const debugPanel = new TooltipDebugPanel(manager);
```

#### æ—¥å¿—ç³»ç»Ÿ

```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

class TooltipLogger {
  private logs: Array<{
    level: LogLevel;
    message: string;
    timestamp: number;
    context?: any;
  }> = [];
  
  private maxLogs = 1000;
  private currentLevel = LogLevel.INFO;
  
  debug(message: string, context?: any): void {
    this.log(LogLevel.DEBUG, message, context);
  }
  
  info(message: string, context?: any): void {
    this.log(LogLevel.INFO, message, context);
  }
  
  warn(message: string, context?: any): void {
    this.log(LogLevel.WARN, message, context);
  }
  
  error(message: string, context?: any): void {
    this.log(LogLevel.ERROR, message, context);
  }
  
  private log(level: LogLevel, message: string, context?: any): void {
    if (level < this.currentLevel) return;
    
    const logEntry = {
      level,
      message,
      timestamp: Date.now(),
      context
    };
    
    this.logs.push(logEntry);
    
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    
    this.outputToConsole(logEntry);
  }
  
  private outputToConsole(entry: any): void {
    const levelNames = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    const levelName = levelNames[entry.level];
    const timestamp = new Date(entry.timestamp).toISOString();
    
    const consoleMethod = ['log', 'info', 'warn', 'error'][entry.level];
    console[consoleMethod](`[${timestamp}] [${levelName}] ${entry.message}`, entry.context || '');
  }
  
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }
  
  clearLogs(): void {
    this.logs = [];
  }
}

// é›†æˆæ—¥å¿—çš„ TooltipManager
class LoggingTooltipManager extends TooltipManager {
  private logger = new TooltipLogger();
  
  async showTooltip(options: ShowTooltipOptions): Promise<void> {
    this.logger.info('æ˜¾ç¤º Tooltip', { word: options.word });
    
    try {
      await super.showTooltip(options);
      this.logger.debug('Tooltip æ˜¾ç¤ºæˆåŠŸ');
    } catch (error) {
      this.logger.error('Tooltip æ˜¾ç¤ºå¤±è´¥', { error, options });
      throw error;
    }
  }
  
  hideTooltip(immediate?: boolean): void {
    this.logger.info('éšè— Tooltip', { immediate });
    super.hideTooltip(immediate);
  }
  
  getLogger(): TooltipLogger {
    return this.logger;
  }
}
```

---

**ç»´æŠ¤è€…**: Lucid å¼€å‘å›¢é˜Ÿ  
**ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-06-24 21:11:39