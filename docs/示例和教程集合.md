# Lucid 浏览器扩展 - 示例和教程集合

**版本**: v1.0  
**更新时间**: 2025-06-24 21:11:39  
**适用版本**: 新架构 v1.0+

## 📖 概述

本文档提供 Lucid 浏览器扩展新架构的完整示例和教程，包括常用场景、扩展开发指南和故障排查方法。

## 🚀 快速开始示例

### 1. 基础 Tooltip 显示

最简单的 Tooltip 使用示例：

```typescript
import { TooltipManager } from '@utils/dom/managers/TooltipManager';

// 获取管理器实例
const tooltipManager = TooltipManager.getInstance();

// 基础使用
async function showBasicTooltip() {
  const targetElement = document.getElementById('word-span');
  
  await tooltipManager.showTooltip({
    word: 'hello',
    translation: '你好',
    targetElement: targetElement
  });
}

// 绑定鼠标事件
document.querySelectorAll('.word').forEach(element => {
  element.addEventListener('mouseenter', async () => {
    const word = element.textContent;
    const translation = await getTranslation(word); // 假设的翻译函数
    
    await tooltipManager.showTooltip({
      word,
      translation,
      targetElement: element as HTMLElement
    });
  });
  
  element.addEventListener('mouseleave', () => {
    tooltipManager.hideTooltip();
  });
});
```

### 2. 完整功能 Tooltip

包含音标、词性和例句的完整示例：

```typescript
async function showFullTooltip() {
  const element = document.getElementById('target-word');
  
  await tooltipManager.showTooltip({
    word: 'beautiful',
    translation: '美丽的，漂亮的',
    phonetic: '/ˈbjuːtɪfl/',
    partOfSpeech: 'adjective',
    targetElement: element,
    preferredPosition: 'top'
  });
}
```

## 🎯 常用场景示例

### 场景1: 网页文章阅读助手

为网页文章添加单词查询功能：

```typescript
class ArticleReadingAssistant {
  private tooltipManager: TooltipManager;
  
  constructor() {
    this.tooltipManager = TooltipManager.getInstance();
    this.initializeReadingMode();
  }
  
  private initializeReadingMode(): void {
    this.enableWordSelection();
    this.setupKeyboardShortcuts();
    this.setupStateListeners();
  }
  
  private enableWordSelection(): void {
    document.addEventListener('mouseup', async (event) => {
      const selection = window.getSelection();
      const selectedText = selection?.toString().trim();
      
      if (!selectedText || selectedText.length > 50) {
        return;
      }
      
      if (this.isSingleWord(selectedText)) {
        await this.showWordTooltip(selectedText, event.target as HTMLElement);
      }
    });
  }
  
  private async showWordTooltip(word: string, element: HTMLElement): Promise<void> {
    try {
      // 显示加载状态
      await this.tooltipManager.showTooltip({
        word,
        translation: '查询中...',
        targetElement: element
      });
      
      // 查询翻译（模拟API调用）
      const definition = await this.getTranslation(word);
      
      // 更新内容
      await this.tooltipManager.showTooltip({
        word,
        translation: definition.translation,
        phonetic: definition.phonetic,
        partOfSpeech: definition.partOfSpeech,
        targetElement: element
      });
      
    } catch (error) {
      console.error('查询单词失败:', error);
      await this.tooltipManager.showTooltip({
        word,
        translation: '查询失败，请重试',
        targetElement: element
      });
    }
  }
  
  private setupKeyboardShortcuts(): void {
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        this.tooltipManager.hideTooltip(true);
      }
      if (event.key === 'Enter' && this.tooltipManager.isVisible()) {
        this.tooltipManager.toggleExpanded();
      }
    });
  }
  
  private setupStateListeners(): void {
    this.tooltipManager.addStateChangeListener((event) => {
      switch (event.type) {
        case 'show':
          this.recordLookup(event.state.word);
          break;
        case 'hide':
          document.body.classList.remove('tooltip-active');
          break;
      }
    });
  }
  
  private isSingleWord(text: string): boolean {
    return /^[a-zA-Z-']+$/.test(text) && !text.includes(' ');
  }
  
  private async getTranslation(word: string): Promise<any> {
    // 模拟翻译API
    return {
      translation: '示例翻译',
      phonetic: '/ˈeksəmpl/',
      partOfSpeech: 'noun'
    };
  }
  
  private recordLookup(word: string): void {
    const history = JSON.parse(localStorage.getItem('word-history') || '[]');
    history.push({ word, timestamp: Date.now() });
    localStorage.setItem('word-history', JSON.stringify(history.slice(-100)));
  }
}

// 使用示例
const assistant = new ArticleReadingAssistant();
```

### 场景2: 学习模式增强

为在线学习平台添加智能学习助手：

```typescript
class LearningModeEnhancer {
  private tooltipManager: TooltipManager;
  private learningStats = {
    wordsLearned: 0,
    correctAnswers: 0,
    totalAttempts: 0
  };
  
  constructor() {
    this.tooltipManager = TooltipManager.getInstance();
    this.setupLearningMode();
  }
  
  private setupLearningMode(): void {
    this.addQuizMode();
    this.addProgressTracking();
  }
  
  private addQuizMode(): void {
    // 双击单词进入测试模式
    document.addEventListener('dblclick', async (event) => {
      const target = event.target as HTMLElement;
      const word = this.extractWord(target);
      
      if (word) {
        await this.startWordQuiz(word, target);
      }
    });
  }
  
  private async startWordQuiz(word: string, element: HTMLElement): Promise<void> {
    const definition = await this.getWordDefinition(word);
    
    await this.tooltipManager.showTooltip({
      word,
      translation: this.createQuizInterface(definition),
      targetElement: element,
      preferredPosition: 'bottom'
    });
    
    this.setupQuizInteraction(word, definition);
  }
  
  private createQuizInterface(definition: any): string {
    return `
      <div class="quiz-interface">
        <div class="quiz-question">这个单词的意思是？</div>
        <div class="quiz-options">
          <button class="quiz-option" data-answer="correct">${definition.translation}</button>
          <button class="quiz-option" data-answer="wrong">${this.getRandomTranslation()}</button>
          <button class="quiz-option" data-answer="wrong">${this.getRandomTranslation()}</button>
        </div>
        <div class="quiz-stats">学习进度: ${this.learningStats.wordsLearned} 个单词</div>
      </div>
    `;
  }
  
  private setupQuizInteraction(word: string, definition: any): void {
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      if (target.classList.contains('quiz-option')) {
        this.handleQuizAnswer(target, word, definition);
      }
    });
  }
  
  private async handleQuizAnswer(button: HTMLElement, word: string, definition: any): Promise<void> {
    const isCorrect = button.dataset.answer === 'correct';
    
    this.learningStats.totalAttempts++;
    if (isCorrect) {
      this.learningStats.correctAnswers++;
      this.learningStats.wordsLearned++;
    }
    
    const resultMessage = isCorrect ? '✅ 正确！' : '❌ 错误，正确答案是：' + definition.translation;
    
    await this.tooltipManager.showTooltip({
      word,
      translation: `
        <div class="quiz-result ${isCorrect ? 'correct' : 'incorrect'}">
          ${resultMessage}
          <div class="learning-progress">
            正确率: ${Math.round(this.learningStats.correctAnswers / this.learningStats.totalAttempts * 100)}%
          </div>
        </div>
      `,
      targetElement: button.closest('[data-lucid-tooltip]') as HTMLElement
    });
    
    setTimeout(() => this.tooltipManager.hideTooltip(true), 2000);
  }
  
  private addProgressTracking(): void {
    this.tooltipManager.addStateChangeListener((event) => {
      if (event.type === 'show') {
        this.trackLearningActivity(event.state.word);
      }
    });
  }
  
  private extractWord(element: HTMLElement): string | null {
    const selection = window.getSelection();
    const selectedText = selection?.toString().trim();
    
    if (selectedText && /^[a-zA-Z-']+$/.test(selectedText)) {
      return selectedText;
    }
    
    return element.textContent?.match(/\b[a-zA-Z-']+\b/)?.[0] || null;
  }
  
  private async getWordDefinition(word: string): Promise<any> {
    return {
      translation: '示例翻译',
      phonetic: '/ˈeksəmpl/',
      partOfSpeech: 'noun'
    };
  }
  
  private getRandomTranslation(): string {
    const randomTranslations = ['错误选项1', '错误选项2', '错误选项3'];
    return randomTranslations[Math.floor(Math.random() * randomTranslations.length)];
  }
  
  private trackLearningActivity(word: string): void {
    const activity = { word, timestamp: Date.now() };
    const activities = JSON.parse(localStorage.getItem('learning-activities') || '[]');
    activities.push(activity);
    localStorage.setItem('learning-activities', JSON.stringify(activities.slice(-1000)));
  }
}

// 使用示例
const learningEnhancer = new LearningModeEnhancer();
```

## 🔧 扩展开发教程

### 教程1: 创建自定义位置策略

```typescript
// 继承基础位置计算器
class CustomPositioner extends TooltipPositioner {
  /**
   * 自定义位置计算：始终显示在屏幕中央
   */
  calculateCenterPosition(options: PositionOptions): Position {
    const viewport = this.getViewportSize();
    
    return {
      x: viewport.width / 2 - 150,
      y: viewport.height / 2 - 100
    };
  }
  
  calculatePosition(options: PositionOptions): Position {
    if (options.preferredPosition === 'center') {
      return this.calculateCenterPosition(options);
    }
    return super.calculatePosition(options);
  }
  
  private getViewportSize(): { width: number; height: number } {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
}

// 使用自定义位置策略
class CustomTooltipManager extends TooltipManager {
  constructor() {
    super();
    this.positioner = new CustomPositioner();
  }
}

const customManager = new CustomTooltipManager();
await customManager.showTooltip({
  word: 'center',
  translation: '中央显示',
  targetElement: element,
  preferredPosition: 'center'
});
```

### 教程2: 创建自定义渲染器

```typescript
// 创建暗色主题渲染器
class DarkThemeRenderer extends TooltipRenderer {
  render(options: TooltipRenderOptions): HTMLElement {
    const element = super.render(options);
    
    element.classList.add('dark-theme');
    this.applyDarkTheme(element);
    
    return element;
  }
  
  private applyDarkTheme(element: HTMLElement): void {
    const style = element.style;
    style.backgroundColor = '#2d3748';
    style.color = '#f7fafc';
    style.border = '1px solid #4a5568';
    style.boxShadow = '0 10px 25px rgba(0, 0, 0, 0.5)';
  }
}

// 创建动画渲染器
class AnimatedRenderer extends TooltipRenderer {
  render(options: TooltipRenderOptions): HTMLElement {
    const element = super.render(options);
    this.addEntranceAnimation(element);
    return element;
  }
  
  private addEntranceAnimation(element: HTMLElement): void {
    element.style.opacity = '0';
    element.style.transform = 'scale(0.8) translateY(-10px)';
    element.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    
    requestAnimationFrame(() => {
      element.style.opacity = '1';
      element.style.transform = 'scale(1) translateY(0)';
    });
  }
  
  cleanup(): void {
    const element = this.getCurrentTooltip();
    if (element) {
      element.style.opacity = '0';
      element.style.transform = 'scale(0.8) translateY(-10px)';
      setTimeout(() => super.cleanup(), 300);
    } else {
      super.cleanup();
    }
  }
}

// 使用自定义渲染器
const darkManager = new TooltipManager();
darkManager.setRenderer(new DarkThemeRenderer());

const animatedManager = new TooltipManager();
animatedManager.setRenderer(new AnimatedRenderer());
```

### 教程3: 创建自定义事件处理器

```typescript
// 手势事件处理器
class GestureEventHandler extends TooltipEventHandler {
  private touchStartTime = 0;
  private touchStartPosition = { x: 0, y: 0 };
  
  constructor(options: EventHandlerOptions) {
    super(options);
    this.setupTouchEvents();
  }
  
  private setupTouchEvents(): void {
    document.addEventListener('touchstart', (event) => this.handleTouchStart(event));
    document.addEventListener('touchend', (event) => this.handleTouchEnd(event));
  }
  
  private handleTouchStart(event: TouchEvent): void {
    const touch = event.touches[0];
    this.touchStartTime = Date.now();
    this.touchStartPosition = { x: touch.clientX, y: touch.clientY };
  }
  
  private handleTouchEnd(event: TouchEvent): void {
    const touchDuration = Date.now() - this.touchStartTime;
    const touch = event.changedTouches[0];
    const distance = this.calculateDistance(
      this.touchStartPosition,
      { x: touch.clientX, y: touch.clientY }
    );
    
    // 长按手势
    if (touchDuration > 500 && distance < 10) {
      this.handleLongPress(event);
    }
    
    // 滑动手势
    if (distance > 50) {
      this.handleSwipe(event);
    }
  }
  
  private handleLongPress(event: TouchEvent): void {
    const target = event.target as HTMLElement;
    const word = this.extractWordFromElement(target);
    
    if (word) {
      this.showTooltipForWord(word, target);
    }
  }
  
  private handleSwipe(event: TouchEvent): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.hide(true);
    }
  }
  
  private calculateDistance(point1: {x: number, y: number}, point2: {x: number, y: number}): number {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
  }
}

// 键盘快捷键处理器
class KeyboardShortcutHandler extends TooltipEventHandler {
  private shortcuts = new Map<string, () => void>();
  
  constructor(options: EventHandlerOptions) {
    super(options);
    this.setupShortcuts();
  }
  
  private setupShortcuts(): void {
    this.registerShortcut('Ctrl+T', () => this.toggleTooltip());
    this.registerShortcut('Ctrl+E', () => this.expandTooltip());
    this.registerShortcut('Ctrl+H', () => this.hideTooltip());
    
    document.addEventListener('keydown', (event) => {
      this.handleKeyboardShortcut(event);
    });
  }
  
  private registerShortcut(shortcut: string, handler: () => void): void {
    this.shortcuts.set(shortcut, handler);
  }
  
  private handleKeyboardShortcut(event: KeyboardEvent): void {
    const shortcut = this.buildShortcutString(event);
    const handler = this.shortcuts.get(shortcut);
    
    if (handler) {
      event.preventDefault();
      handler();
    }
  }
  
  private buildShortcutString(event: KeyboardEvent): string {
    const parts = [];
    if (event.ctrlKey) parts.push('Ctrl');
    if (event.altKey) parts.push('Alt');
    if (event.shiftKey) parts.push('Shift');
    parts.push(event.key);
    return parts.join('+');
  }
  
  private toggleTooltip(): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.hide();
    } else {
      this.showLastTooltip();
    }
  }
  
  private expandTooltip(): void {
    if (this.stateManager.isVisible()) {
      this.stateManager.expand();
    }
  }
  
  private hideTooltip(): void {
    this.stateManager.hide(true);
  }
}
```

## 🚨 故障排查指南

### 常见问题和解决方案

#### 1. Tooltip 不显示

**检查目标元素**:
```typescript
const targetElement = document.getElementById('target');
if (!targetElement) {
  console.error('目标元素不存在');
}

if (!document.contains(targetElement)) {
  console.error('目标元素不在 DOM 中');
}

const rect = targetElement.getBoundingClientRect();
if (rect.width === 0 || rect.height === 0) {
  console.error('目标元素不可见');
}
```

**调试代码**:
```typescript
async function debugTooltipDisplay() {
  const manager = TooltipManager.getInstance();
  
  try {
    console.log('管理器统计:', manager.getStats());
    
    await manager.showTooltip({
      word: 'debug',
      translation: '调试',
      targetElement: document.body
    });
    
    console.log('是否可见:', manager.isVisible());
    console.log('当前单词:', manager.getCurrentWord());
    
  } catch (error) {
    console.error('显示失败:', error);
    if (error instanceof TooltipError) {
      console.error('错误代码:', error.code);
    }
  }
}
```

#### 2. 位置计算错误

**调试位置计算**:
```typescript
function debugPositionCalculation() {
  const manager = TooltipManager.getInstance();
  const targetElement = document.getElementById('target');
  const targetRect = targetElement.getBoundingClientRect();
  
  console.log('目标元素位置:', {
    x: targetRect.left,
    y: targetRect.top,
    width: targetRect.width,
    height: targetRect.height
  });
  
  const viewport = {
    width: window.innerWidth,
    height: window.innerHeight,
    scrollX: window.scrollX,
    scrollY: window.scrollY
  };
  
  console.log('视口信息:', viewport);
}
```

**修复位置问题**:
```typescript
class FixedPositioner extends TooltipPositioner {
  calculatePosition(options: PositionOptions): Position {
    const basePosition = super.calculatePosition(options);
    const viewport = this.getViewport();
    const tooltipRect = this.getTooltipRect(options.tooltipElement);
    
    // 边界检查和修正
    if (basePosition.x < 0) basePosition.x = 10;
    if (basePosition.x + tooltipRect.width > viewport.width) {
      basePosition.x = viewport.width - tooltipRect.width - 10;
    }
    if (basePosition.y < 0) basePosition.y = 10;
    if (basePosition.y + tooltipRect.height > viewport.height) {
      basePosition.y = viewport.height - tooltipRect.height - 10;
    }
    
    return basePosition;
  }
}
```

#### 3. 内存泄漏检测

```typescript
function detectMemoryLeaks() {
  const initialMemory = (performance as any).memory?.usedJSHeapSize;
  let tooltipCount = 0;
  
  const interval = setInterval(() => {
    tooltipCount++;
    
    const manager = TooltipManager.getInstance();
    manager.showTooltip({
      word: `test-${tooltipCount}`,
      translation: '测试',
      targetElement: document.body
    }).then(() => {
      setTimeout(() => manager.hideTooltip(true), 100);
    });
    
    if (tooltipCount % 100 === 0) {
      const currentMemory = (performance as any).memory?.usedJSHeapSize;
      const memoryIncrease = currentMemory - initialMemory;
      
      console.log(`创建了 ${tooltipCount} 个 tooltip`);
      console.log(`内存增长: ${(memoryIncrease / 1024 / 1024).toFixed(2)} MB`);
      
      if (memoryIncrease > 50 * 1024 * 1024) {
        console.warn('检测到可能的内存泄漏');
        clearInterval(interval);
      }
    }
    
    if (tooltipCount >= 1000) {
      clearInterval(interval);
    }
  }, 50);
}
```

#### 4. 性能优化

**性能分析**:
```typescript
class PerformanceAnalyzer {
  private measurements = new Map<string, number[]>();
  
  async measureTooltipPerformance() {
    const manager = TooltipManager.getInstance();
    const testElement = document.createElement('div');
    document.body.appendChild(testElement);
    
    for (let i = 0; i < 50; i++) {
      const startTime = performance.now();
      
      await manager.showTooltip({
        word: `test-${i}`,
        translation: `测试-${i}`,
        targetElement: testElement
      });
      
      const showTime = performance.now() - startTime;
      this.recordMeasurement('show', showTime);
      
      manager.hideTooltip(true);
      await this.waitForFrame();
    }
    
    document.body.removeChild(testElement);
    this.printResults();
  }
  
  private recordMeasurement(operation: string, time: number): void {
    if (!this.measurements.has(operation)) {
      this.measurements.set(operation, []);
    }
    this.measurements.get(operation)!.push(time);
  }
  
  private printResults(): void {
    for (const [operation, times] of this.measurements) {
      const avg = times.reduce((a, b) => a + b) / times.length;
      const max = Math.max(...times);
      const min = Math.min(...times);
      
      console.log(`${operation}操作:`);
      console.log(`  平均: ${avg.toFixed(2)}ms`);
      console.log(`  最大: ${max.toFixed(2)}ms`);
      console.log(`  最小: ${min.toFixed(2)}ms`);
      
      if (avg > 16) {
        console.warn(`  ⚠️  ${operation}操作可能影响性能`);
      }
    }
  }
  
  private waitForFrame(): Promise<void> {
    return new Promise(resolve => requestAnimationFrame(() => resolve()));
  }
}
```

**防抖优化**:
```typescript
class OptimizedTooltipManager extends TooltipManager {
  private showDebounce = this.debounce(super.showTooltip.bind(this), 200);
  private hideDebounce = this.debounce(super.hideTooltip.bind(this), 100);
  
  async showTooltip(options: ShowTooltipOptions): Promise<void> {
    return this.showDebounce(options);
  }
  
  hideTooltip(immediate?: boolean): void {
    if (immediate) {
      super.hideTooltip(true);
    } else {
      this.hideDebounce();
    }
  }
  
  private debounce<T extends (...args: any[]) => any>(
    func: T, 
    wait: number
  ): (...args: Parameters<T>) => Promise<ReturnType<T>> {
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>): Promise<ReturnType<T>> => {
      return new Promise((resolve) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          resolve(func(...args));
        }, wait);
      });
    };
  }
}
```

### 调试工具

#### 开发者调试面板

```typescript
class TooltipDebugPanel {
  private panel: HTMLElement;
  private manager: TooltipManager;
  
  constructor(manager: TooltipManager) {
    this.manager = manager;
    this.createPanel();
    this.setupRealTimeUpdates();
  }
  
  private createPanel(): void {
    this.panel = document.createElement('div');
    this.panel.innerHTML = `
      <div style="
        position: fixed;
        top: 10px;
        right: 10px;
        width: 300px;
        background: white;
        border: 1px solid #ccc;
        padding: 10px;
        z-index: 999999;
        font-family: monospace;
        font-size: 12px;
      ">
        <h3>Tooltip 调试面板</h3>
        <div id="debug-stats"></div>
        <div>
          <button onclick="this.clearStats()">清除统计</button>
          <button onclick="this.exportLogs()">导出日志</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(this.panel);
  }
  
  private setupRealTimeUpdates(): void {
    setInterval(() => this.updateStats(), 1000);
  }
  
  private updateStats(): void {
    const stats = this.manager.getStats();
    const statsElement = this.panel.querySelector('#debug-stats');
    
    if (statsElement) {
      statsElement.innerHTML = `
        <div>状态: ${stats.state.visible ? '显示' : '隐藏'}</div>
        <div>当前单词: ${stats.state.word || '无'}</div>
        <div>显示次数: ${stats.events.totalShows}</div>
        <div>隐藏次数: ${stats.events.totalHides}</div>
        <div>内存使用: ${this.getMemoryUsage()}</div>
      `;
    }
  }
  
  private getMemoryUsage(): string {
    const memory = (performance as any).memory;
    return memory ? `${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB` : '不可用';
  }
}

// 使用调试面板
const manager = TooltipManager.getInstance();
const debugPanel = new TooltipDebugPanel(manager);
```

#### 日志系统

```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

class TooltipLogger {
  private logs: Array<{
    level: LogLevel;
    message: string;
    timestamp: number;
    context?: any;
  }> = [];
  
  private maxLogs = 1000;
  private currentLevel = LogLevel.INFO;
  
  debug(message: string, context?: any): void {
    this.log(LogLevel.DEBUG, message, context);
  }
  
  info(message: string, context?: any): void {
    this.log(LogLevel.INFO, message, context);
  }
  
  warn(message: string, context?: any): void {
    this.log(LogLevel.WARN, message, context);
  }
  
  error(message: string, context?: any): void {
    this.log(LogLevel.ERROR, message, context);
  }
  
  private log(level: LogLevel, message: string, context?: any): void {
    if (level < this.currentLevel) return;
    
    const logEntry = {
      level,
      message,
      timestamp: Date.now(),
      context
    };
    
    this.logs.push(logEntry);
    
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    
    this.outputToConsole(logEntry);
  }
  
  private outputToConsole(entry: any): void {
    const levelNames = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    const levelName = levelNames[entry.level];
    const timestamp = new Date(entry.timestamp).toISOString();
    
    const consoleMethod = ['log', 'info', 'warn', 'error'][entry.level];
    console[consoleMethod](`[${timestamp}] [${levelName}] ${entry.message}`, entry.context || '');
  }
  
  exportLogs(): string {
    return JSON.stringify(this.logs, null, 2);
  }
  
  clearLogs(): void {
    this.logs = [];
  }
}

// 集成日志的 TooltipManager
class LoggingTooltipManager extends TooltipManager {
  private logger = new TooltipLogger();
  
  async showTooltip(options: ShowTooltipOptions): Promise<void> {
    this.logger.info('显示 Tooltip', { word: options.word });
    
    try {
      await super.showTooltip(options);
      this.logger.debug('Tooltip 显示成功');
    } catch (error) {
      this.logger.error('Tooltip 显示失败', { error, options });
      throw error;
    }
  }
  
  hideTooltip(immediate?: boolean): void {
    this.logger.info('隐藏 Tooltip', { immediate });
    super.hideTooltip(immediate);
  }
  
  getLogger(): TooltipLogger {
    return this.logger;
  }
}
```

---

**维护者**: Lucid 开发团队  
**版本**: v1.0  
**最后更新**: 2025-06-24 21:11:39