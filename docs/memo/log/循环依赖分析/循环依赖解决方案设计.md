# 🔄 TooltipManager 与 ToolpopupManager 循环依赖解决方案

## 📋 问题概述

### 🎯 核心问题
- **循环依赖**：TooltipManager 导入 ToolpopupManager，ToolpopupManager 通过动态导入使用 TooltipManager
- **代码异味**：`let TooltipManager: any = null` 破坏类型安全
- **违反原则**：违反 SOLID 原则中的依赖倒置原则
- **测试困难**：循环依赖导致单元测试复杂化

### 📊 影响评估
- **维护性**：❌ 新开发者理解困难
- **扩展性**：❌ 难以添加新的 UI 组件
- **测试性**：❌ Mock 设置复杂
- **稳定性**：⚠️ 潜在的运行时错误风险

## 🎯 解决方案：事件驱动架构

### 🏗️ 架构设计原则
1. **单一职责**：每个管理器只负责自己的 UI 组件
2. **开闭原则**：通过事件接口扩展功能
3. **依赖倒置**：依赖抽象的事件接口，而非具体实现
4. **接口隔离**：定义最小化的事件接口

### 🔧 技术实现策略

#### 1. 扩展 SimpleEventManager
```typescript
// 新增全局事件总线功能
export interface LucidUIEvent<T = any> {
  type: string;
  payload: T;
  timestamp: number;
  source: string;
}

export class SimpleEventManager {
  // 现有功能保持不变...
  
  // 新增全局事件功能
  public dispatchGlobalEvent<T>(eventType: string, payload: T, source: string): void
  public subscribeGlobalEvent<T>(eventType: string, handler: (event: LucidUIEvent<T>) => void): () => void
}
```

#### 2. 定义事件常量
```typescript
// src/constants/uiEvents.ts
export const UI_EVENTS = {
  TOOLTIP: {
    SHOW: 'lucid:tooltip:show',
    HIDE: 'lucid:tooltip:hide',
    TRANSITION_TO_POPUP: 'lucid:tooltip:transition-to-popup'
  },
  TOOLPOPUP: {
    SHOW: 'lucid:toolpopup:show',
    HIDE: 'lucid:toolpopup:hide',
    SHOWN: 'lucid:toolpopup:shown'
  },
  UI_STATE: {
    HIDE_ALL: 'lucid:ui:hide-all',
    STATE_CHANGE: 'lucid:ui:state-change'
  }
} as const;
```

#### 3. 重构 TooltipManager
```typescript
// 移除直接导入 ToolpopupManager
// import { ToolpopupManager } from './toolpopupManager'; // ❌ 删除

export class TooltipManager {
  private eventManager = SimpleEventManager.getInstance();
  
  constructor() {
    // 监听全局隐藏事件
    this.eventManager.subscribeGlobalEvent(
      UI_EVENTS.UI_STATE.HIDE_ALL,
      () => this.hideTooltip(0)
    );
  }
  
  private addShiftKeyListener(targetElement: HTMLElement, word: string): void {
    const shiftKeyHandler = (event: KeyboardEvent) => {
      if (event.key === 'Shift' && this.currentTooltip) {
        // 发送事件而非直接调用
        this.eventManager.dispatchGlobalEvent(
          UI_EVENTS.TOOLTIP.TRANSITION_TO_POPUP,
          { word, targetElement, fromTooltip: this.currentTooltip },
          'TooltipManager'
        );
        this.hideTooltip(0);
      }
    };
    // ...
  }
}
```

#### 4. 重构 ToolpopupManager
```typescript
// 移除动态导入逻辑
// let TooltipManager: any = null; // ❌ 删除

export class ToolpopupManager {
  private eventManager = SimpleEventManager.getInstance();
  
  constructor() {
    // 监听 tooltip 转换事件
    this.eventManager.subscribeGlobalEvent(
      UI_EVENTS.TOOLTIP.TRANSITION_TO_POPUP,
      (event) => this.handleTooltipTransition(event.payload)
    );
    
    // 监听全局隐藏事件
    this.eventManager.subscribeGlobalEvent(
      UI_EVENTS.UI_STATE.HIDE_ALL,
      () => this.hideToolpopup()
    );
  }
  
  public async showToolpopup(word: string, referenceElement?: HTMLElement, fromTooltip?: HTMLElement): Promise<void> {
    // 发送隐藏所有其他 UI 组件的事件
    this.eventManager.dispatchGlobalEvent(
      UI_EVENTS.UI_STATE.HIDE_ALL,
      { except: 'toolpopup' },
      'ToolpopupManager'
    );
    
    // 显示逻辑...
    
    // 发送已显示事件
    this.eventManager.dispatchGlobalEvent(
      UI_EVENTS.TOOLPOPUP.SHOWN,
      { word, element: this.currentToolpopup },
      'ToolpopupManager'
    );
  }
}
```

## 📅 实施计划

### 🚀 阶段一：基础设施准备（1-2天）
- [ ] 扩展 SimpleEventManager 添加全局事件功能
- [ ] 创建事件常量定义文件
- [ ] 定义事件接口和类型
- [ ] 编写基础测试用例

### 🔧 阶段二：TooltipManager 重构（1天）
- [ ] 移除对 ToolpopupManager 的直接导入
- [ ] 实现事件驱动的 Shift 键处理
- [ ] 添加事件监听器管理
- [ ] 更新相关测试

### 🔧 阶段三：ToolpopupManager 重构（1天）
- [ ] 移除动态导入逻辑
- [ ] 实现事件驱动的显示/隐藏逻辑
- [ ] 添加事件监听器管理
- [ ] 更新相关测试

### 🧪 阶段四：测试与验证（1天）
- [ ] 端到端测试：tooltip → toolpopup 转换
- [ ] 性能测试：事件系统开销
- [ ] 回归测试：确保功能无退化
- [ ] 代码审查和优化

### 📚 阶段五：文档与清理（0.5天）
- [ ] 更新架构文档
- [ ] 创建事件使用指南
- [ ] 清理废弃代码
- [ ] 添加代码注释

## 🎯 预期收益

### ✅ 技术收益
- **解耦合**：完全消除循环依赖
- **类型安全**：恢复完整的 TypeScript 类型检查
- **可测试性**：每个组件可独立测试
- **可扩展性**：易于添加新的 UI 组件

### ✅ 开发体验
- **理解性**：清晰的模块边界和交互契约
- **维护性**：事件驱动的调试和监控
- **重用性**：事件系统可用于其他组件

### ✅ 用户体验
- **稳定性**：减少运行时错误风险
- **性能**：优化的事件处理机制
- **一致性**：统一的 UI 状态管理

## ⚠️ 风险评估与缓解

### 🔍 潜在风险
1. **事件调试复杂性**
   - 缓解：添加详细的事件日志和调试工具
2. **事件监听器泄漏**
   - 缓解：完善的清理机制和生命周期管理
3. **事件时序问题**
   - 缓解：明确的事件处理顺序和异步处理

### 🛡️ 质量保证
- **代码审查**：所有变更需要 peer review
- **测试覆盖**：确保 90%+ 的测试覆盖率
- **性能监控**：监控事件系统的性能影响
- **向后兼容**：确保现有功能无破坏性变更

## 📈 成功指标

- [ ] 循环依赖完全消除
- [ ] TypeScript 编译无警告
- [ ] 测试覆盖率 ≥ 90%
- [ ] 性能无明显退化（< 5ms 延迟）
- [ ] 代码复杂度降低（圈复杂度 < 10）

---

**创建时间**：2024-01-XX  
**负责人**：开发团队  
**审查状态**：待审查  
**实施状态**：设计阶段