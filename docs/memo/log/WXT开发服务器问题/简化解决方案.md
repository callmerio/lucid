# 🚀 WXT开发服务器问题 - 简化解决方案

## 🎯 问题总结

### 原始问题
1. **端口占用错误**：`ECONNREFUSED 127.0.0.1:54703`
2. **Chrome进程锁定**：需要手动清理缓存和重新安装依赖
3. **脚本循环调用**：启动脚本无限递归

### 根本原因
1. **Chrome进程锁定机制**：SingletonLock防止多实例使用同一用户数据目录
2. **WXT进程清理不完整**：异常退出时Chrome子进程没有被正确清理
3. **npm脚本循环**：`pnpm dev` → `dev-simple.sh` → `pnpm dev` 无限循环

## ✅ 最终解决方案

### 方案一：每次使用新的浏览器实例（推荐）

#### 核心思路
- 每次启动WXT时使用唯一的用户数据目录（时间戳）
- 避免进程间的锁定冲突
- 自动清理旧的临时目录

#### 实现方式

**1. 优化web-ext.config.ts**
```typescript
// 生成唯一的用户数据目录，避免进程冲突
const timestamp = Date.now();
const uniqueDataDir = `./.wxt/chrome-data-${timestamp}`;

export default defineWebExtConfig({
  chromiumArgs: [
    `--user-data-dir=${uniqueDataDir}`, // 使用时间戳创建唯一目录
    '--disable-features=VizDisplayCompositor',
    '--auto-open-devtools-for-tabs',
    // 其他优化参数...
  ],
  keepProfileChanges: false, // 不保持配置文件更改，每次都是全新实例
});
```

**2. 创建直接启动脚本**
```bash
# scripts/wxt-dev.sh - 直接调用WXT，避免npm脚本循环
#!/bin/bash

# 清理旧的Chrome数据目录（保留最近3个）
cleanup_old_chrome_data() {
    find .wxt -name "chrome-data-*" -type d -print0 | \
    xargs -0 ls -dt | tail -n +4 | xargs -r rm -rf
}

# 直接调用WXT，避免循环
start_wxt_dev() {
    npx wxt  # 直接调用，不通过npm脚本
}
```

**3. 更新package.json**
```json
{
  "scripts": {
    "dev": "./scripts/wxt-dev.sh",           // 主启动命令
    "dev:original": "wxt",                   // 原始WXT命令
    "dev:clean-all": "./scripts/wxt-dev.sh --clean-all"
  }
}
```

## 🎯 使用方法

### 日常开发
```bash
# 正常启动（推荐）
pnpm dev

# 或者直接调用脚本
./scripts/wxt-dev.sh
```

### 清理所有数据
```bash
# 清理所有Chrome数据目录后启动
pnpm run dev:clean-all
```

### 手动清理（如果需要）
```bash
# 清理残留进程和锁定文件
pnpm run dev:cleanup
```

## 📊 解决方案对比

| 方案 | 复杂度 | 可靠性 | 性能 | 推荐度 |
|------|--------|--------|------|--------|
| **新浏览器实例** | 🟢 简单 | 🟢 高 | 🟢 好 | ⭐⭐⭐⭐⭐ |
| 智能清理脚本 | 🟡 中等 | 🟡 中 | 🟢 好 | ⭐⭐⭐ |
| 手动清理 | 🔴 复杂 | 🔴 低 | 🟡 一般 | ⭐ |

## 🎉 方案优势

### ✅ **简单可靠**
- 每次启动都是全新环境，避免状态冲突
- 无需复杂的进程检测和清理逻辑
- 自动清理旧数据，避免磁盘空间浪费

### ✅ **性能优秀**
- 启动速度快，无额外检查开销
- Chrome实例独立，不受历史状态影响
- 内存使用干净，无残留数据

### ✅ **开发友好**
- 一条命令启动，无需记忆复杂参数
- 自动处理所有清理工作
- 支持正常的Ctrl+C退出

### ✅ **扩展性好**
- 易于添加新的清理规则
- 支持不同的启动模式
- 可以轻松集成到CI/CD流程

## 🔧 技术细节

### Chrome数据目录管理
```bash
# 目录结构
.wxt/
├── chrome-data-1704067200000/  # 时间戳目录
├── chrome-data-1704067300000/  # 自动生成
└── chrome-data-1704067400000/  # 保留最近3个
```

### 自动清理策略
- **保留策略**：保留最近3个Chrome数据目录
- **清理时机**：每次启动时自动清理
- **清理范围**：只清理`chrome-data-*`目录，保留其他文件

### 进程管理
- **启动**：使用唯一时间戳目录，避免锁定冲突
- **运行**：独立Chrome实例，不影响其他应用
- **退出**：信号处理确保Chrome进程正确清理

## 🚀 迁移指南

### 从旧方案迁移
1. **更新配置**：使用新的`web-ext.config.ts`
2. **使用新脚本**：`pnpm dev`现在使用新的启动脚本
3. **清理旧数据**：运行`pnpm run dev:clean-all`清理旧的Chrome数据

### 团队部署
1. **更新文档**：告知团队新的启动方式
2. **清理环境**：每个开发者运行一次`dev:clean-all`
3. **验证功能**：确认扩展功能正常工作

## 📋 故障排除

### 常见问题

**Q: 端口仍然被占用怎么办？**
A: 运行`lsof -ti:3000 | xargs kill -9`手动清理端口

**Q: Chrome数据目录太多怎么办？**
A: 运行`pnpm run dev:clean-all`清理所有旧目录

**Q: 扩展没有自动加载怎么办？**
A: 检查Chrome是否正确启动，重新运行`pnpm dev`

### 调试模式
```bash
# 查看详细启动信息
./scripts/wxt-dev.sh --help

# 检查Chrome进程
ps aux | grep chrome | grep wxt

# 检查数据目录
ls -la .wxt/chrome-data-*
```

## 🎯 总结

这个简化解决方案通过**每次使用新的浏览器实例**的策略，从根本上避免了Chrome进程锁定问题。相比复杂的进程管理和清理逻辑，这种方案更加简单、可靠、易于维护。

**核心理念**：与其解决冲突，不如避免冲突。

---

**最后更新**：2024-01-XX  
**维护者**：开发团队  
**状态**：已验证，推荐使用
